---
layout: post
title: JVM垃圾回收与算法
subtitle: 垃圾回收机制与各种回收算法详解
date: 2018-07-06
categories: 技术
tags: java jvm 垃圾回收 算法
cover: 
---

垃圾回收是JVM自动内存管理的核心机制，理解垃圾回收的原理和各种算法对于Java性能优化至关重要。

## 垃圾回收概述

### 什么是垃圾回收
垃圾回收（Garbage Collection，GC）是JVM自动管理内存的机制，自动回收不再使用的对象，释放内存空间。

### 垃圾回收的优势
- **自动内存管理**：程序员无需手动释放内存
- **避免内存泄漏**：自动回收不再使用的对象
- **提高开发效率**：减少内存管理的工作量

### 垃圾回收的缺点
- **性能开销**：GC过程会消耗CPU资源
- **不可预测性**：GC时机不可完全控制
- **内存碎片**：某些算法可能产生内存碎片

## 如何确定垃圾

### 引用计数法
#### 原理
引用计数法通过记录每个对象被引用的次数来判断对象是否为垃圾。

#### 实现方式
- 每个对象维护一个引用计数器
- 对象被引用时计数器+1
- 引用失效时计数器-1
- 计数器为0时对象为垃圾

#### 优点
- **实现简单**：算法简单易懂
- **实时回收**：可以立即回收垃圾对象
- **无停顿**：不需要停止程序执行

#### 缺点
- **循环引用**：无法解决循环引用问题
- **性能开销**：每次引用操作都需要更新计数器
- **内存开销**：每个对象需要额外的计数器空间

#### 示例
```java
// 循环引用示例
class A {
    B b;
}

class B {
    A a;
}

// 创建循环引用
A a = new A();
B b = new B();
a.b = b;
b.a = a;
// 即使a和b都设置为null，引用计数法也无法回收它们
```

### 可达性分析
#### 原理
可达性分析通过从GC Roots开始，标记所有可达的对象，未被标记的对象即为垃圾。

#### GC Roots
- **虚拟机栈中的引用**：局部变量表中的引用
- **方法区中的静态引用**：静态变量引用的对象
- **方法区中的常量引用**：常量池中的引用
- **本地方法栈中的引用**：Native方法引用的对象
- **同步锁持有的对象**：synchronized持有的对象

#### 优点
- **解决循环引用**：可以正确处理循环引用
- **准确性高**：能够准确识别垃圾对象
- **广泛应用**：现代JVM主要使用此方法

#### 缺点
- **需要停顿**：分析过程需要停止程序执行
- **实现复杂**：算法实现相对复杂

#### 示例
```java
// 可达性分析示例
public class GCRootsExample {
    private static Object staticRef; // 静态引用，GC Root
    
    public void method() {
        Object localRef = new Object(); // 局部引用，GC Root
        // 方法执行完毕后，localRef引用的对象可能被回收
    }
}
```

## 垃圾回收算法

### 标记清除算法（Mark-Sweep）

#### 算法过程
1. **标记阶段**：标记所有需要回收的对象
2. **清除阶段**：清除所有被标记的对象

#### 优点
- **实现简单**：算法逻辑简单
- **内存利用率高**：不会浪费内存空间

#### 缺点
- **内存碎片**：产生大量不连续的内存碎片
- **效率较低**：标记和清除过程效率不高
- **需要停顿**：需要停止程序执行

#### 适用场景
- **老年代**：适合老年代垃圾回收
- **内存充足**：内存充足时使用

### 复制算法（Copying）

#### 算法过程
1. **内存划分**：将内存分为两块，使用其中一块
2. **复制存活对象**：将存活对象复制到另一块内存
3. **清空原内存**：清空原内存块
4. **互换角色**：两块内存互换角色

#### 优点
- **无内存碎片**：不会产生内存碎片
- **效率较高**：复制过程效率较高
- **适合新生代**：适合对象生命周期短的新生代

#### 缺点
- **内存利用率低**：只能使用一半内存
- **需要额外空间**：需要额外的内存空间

#### 适用场景
- **新生代**：适合新生代垃圾回收
- **对象生命周期短**：适合对象生命周期短的情况

#### 示例
```java
// 复制算法示例
public class CopyingAlgorithm {
    private Object[] fromSpace = new Object[1000];
    private Object[] toSpace = new Object[1000];
    private int fromIndex = 0;
    private int toIndex = 0;
    
    public void copyAliveObjects() {
        // 复制存活对象到toSpace
        for (int i = 0; i < fromIndex; i++) {
            if (isAlive(fromSpace[i])) {
                toSpace[toIndex++] = fromSpace[i];
            }
        }
        // 清空fromSpace
        clearFromSpace();
        // 互换角色
        swapSpaces();
    }
}
```

### 标记整理算法（Mark-Compact）

#### 算法过程
1. **标记阶段**：标记所有需要回收的对象
2. **整理阶段**：将存活对象向一端移动
3. **清除阶段**：清除边界外的所有对象

#### 优点
- **无内存碎片**：不会产生内存碎片
- **内存利用率高**：内存利用率高
- **适合老年代**：适合老年代垃圾回收

#### 缺点
- **效率较低**：整理过程效率较低
- **需要停顿**：需要停止程序执行

#### 适用场景
- **老年代**：适合老年代垃圾回收
- **内存紧张**：内存紧张时使用

### 分代收集算法

#### 算法原理
分代收集算法根据对象生命周期将内存分为不同代，对不同代使用不同的垃圾回收算法。

#### 新生代特点
- **对象生命周期短**：大部分对象很快死亡
- **使用复制算法**：适合复制算法
- **GC频率高**：Minor GC频率较高

#### 老年代特点
- **对象生命周期长**：对象存活时间长
- **使用标记整理算法**：适合标记整理算法
- **GC频率低**：Major GC频率较低

#### 分代收集的优势
- **针对性优化**：针对不同代的特点优化
- **提高效率**：提高垃圾回收效率
- **减少停顿**：减少GC停顿时间

## 垃圾回收器

### Serial收集器
- **特点**：单线程收集器
- **算法**：新生代使用复制算法，老年代使用标记整理算法
- **适用场景**：客户端应用，内存较小的应用

### Parallel收集器
- **特点**：多线程收集器
- **算法**：新生代使用复制算法，老年代使用标记整理算法
- **适用场景**：服务端应用，注重吞吐量

### CMS收集器
- **特点**：并发收集器
- **算法**：老年代使用标记清除算法
- **适用场景**：注重响应时间的应用

### G1收集器
- **特点**：区域化收集器
- **算法**：整体使用标记整理算法，局部使用复制算法
- **适用场景**：大内存应用，可预测停顿时间

## 性能调优

### GC参数调优
```bash
# 设置堆大小
-Xms512m -Xmx1024m

# 设置新生代大小
-Xmn256m

# 设置新生代比例
-XX:NewRatio=2

# 设置Eden区和Servivor区比例
-XX:SurvivorRatio=8

# 设置对象晋升年龄阈值
-XX:MaxTenuringThreshold=15

# 启用GC日志
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps

# 设置GC收集器
-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+UseConcMarkSweepGC
-XX:+UseG1GC
```

### 监控GC性能
- **GC频率**：监控GC触发频率
- **GC耗时**：监控GC执行时间
- **内存使用**：监控内存使用情况
- **吞吐量**：监控应用吞吐量

### 优化建议
1. **合理设置堆大小**：根据应用需求设置合适的堆内存
2. **选择合适的收集器**：根据应用特点选择GC收集器
3. **优化对象生命周期**：减少对象创建，延长对象生命周期
4. **避免大对象**：减少大对象的创建
5. **监控GC日志**：分析GC性能，持续优化

## 总结

垃圾回收是JVM自动内存管理的核心机制，理解垃圾回收的原理和各种算法对于Java性能优化至关重要。在实际开发中，应该根据应用特点选择合适的GC算法和参数，监控GC性能，持续优化应用性能。

—— 完 ——
