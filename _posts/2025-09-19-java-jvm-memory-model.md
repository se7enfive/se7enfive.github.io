---
layout: post
title: JVM内存模型详解
subtitle: Java虚拟机内存区域与垃圾回收机制
date: 2025-09-19
categories: 技术
tags: java jvm 内存模型 垃圾回收
cover: 
---

本文详细介绍JVM内存模型，包括内存区域划分、垃圾回收机制等核心概念。

## JVM内存区域

### 线程私有区域

#### 1. 程序计数器（Program Counter Register）
- **作用**：记录当前线程执行的字节码指令地址
- **特点**：线程私有，不会发生内存溢出
- **用途**：线程切换时恢复执行位置

#### 2. 虚拟机栈（VM Stack）
- **作用**：存储局部变量、操作数栈、方法出口等
- **特点**：线程私有，FILO结构
- **异常**：StackOverflowError、OutOfMemoryError

#### 3. 本地方法栈（Native Method Stack）
- **作用**：为Native方法服务
- **特点**：线程私有
- **异常**：StackOverflowError、OutOfMemoryError

### 线程共享区域

#### 4. 堆（Heap）
- **作用**：存储对象实例和数组
- **特点**：线程共享，最大内存区域
- **分区**：新生代、老年代
- **异常**：OutOfMemoryError

#### 5. 方法区/永久代（Method Area）
- **作用**：存储类信息、常量、静态变量
- **特点**：线程共享
- **Java8变化**：元空间（Metaspace）替代永久代

## JVM运行时内存

### 新生代（Young Generation）

#### Eden区
- **作用**：新对象分配区域
- **特点**：大部分对象在此创建和销毁

#### ServivorFrom/ServivorTo
- **作用**：Minor GC后存活对象的暂存区
- **特点**：两个区域交替使用

#### Minor GC过程
1. **复制**：Eden、ServivorFrom → ServivorTo，年龄+1
2. **清空**：清空Eden、ServivorFrom
3. **互换**：ServivorTo和ServivorFrom互换

### 老年代（Old Generation）
- **作用**：存储长期存活的对象
- **特点**：使用标记整理算法
- **触发**：Major GC/Full GC

### 永久代（Java8前）
- **作用**：存储类元数据
- **Java8变化**：被元空间替代

## 垃圾回收机制

### 如何确定垃圾

#### 引用计数法
- **原理**：对象被引用时计数+1，引用失效时计数-1
- **缺点**：无法解决循环引用问题

#### 可达性分析
- **原理**：从GC Roots开始，标记所有可达对象
- **GC Roots**：虚拟机栈、方法区、常量池等

### 垃圾回收算法

#### 1. 标记清除算法（Mark-Sweep）
- **过程**：标记所有需要回收的对象，然后清除
- **优点**：实现简单
- **缺点**：产生内存碎片

#### 2. 复制算法（Copying）
- **过程**：将内存分为两块，使用一块，回收时复制存活对象到另一块
- **优点**：无内存碎片
- **缺点**：内存利用率低

#### 3. 标记整理算法（Mark-Compact）
- **过程**：标记存活对象，然后向一端移动
- **优点**：无内存碎片，内存利用率高
- **缺点**：效率较低

#### 4. 分代收集算法
- **新生代**：使用复制算法
- **老年代**：使用标记整理算法

## Java四种引用类型

### 强引用（Strong Reference）
- **特点**：不会被垃圾回收
- **示例**：`Object obj = new Object()`

### 软引用（Soft Reference）
- **特点**：内存不足时被回收
- **用途**：缓存实现

### 弱引用（Weak Reference）
- **特点**：下次GC时被回收
- **用途**：避免内存泄漏

### 虚引用（Phantom Reference）
- **特点**：无法获取对象实例
- **用途**：对象回收通知

## GC垃圾收集器

### 新生代收集器
- **Serial收集器**：单线程，适合客户端
- **Parallel收集器**：多线程，适合服务端
- **ParNew收集器**：多线程，配合CMS使用

### 老年代收集器
- **Serial Old收集器**：单线程，标记整理
- **Parallel Old收集器**：多线程，标记整理
- **CMS收集器**：并发收集，低停顿
- **G1收集器**：区域化收集，可预测停顿

## 性能调优建议

1. **合理设置堆大小**：-Xms和-Xmx
2. **选择合适的垃圾收集器**
3. **监控GC日志**：-XX:+PrintGCDetails
4. **避免频繁Full GC**
5. **合理设置新生代比例**：-XX:NewRatio

## 总结

JVM内存模型是Java性能优化的基础，理解内存区域划分和垃圾回收机制对于编写高性能Java应用至关重要。建议结合实际项目进行调优实践。

—— 完 ——
