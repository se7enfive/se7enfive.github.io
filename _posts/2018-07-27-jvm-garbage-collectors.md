---
layout: post
title: JVM垃圾收集器详解
subtitle: 各种垃圾收集器的特点与应用场景
date: 2018-07-27
categories: 技术
tags: java jvm 垃圾收集器
cover: 
---

JVM垃圾收集器是垃圾回收算法的具体实现，理解各种垃圾收集器的特点和应用场景对于选择合适的GC策略至关重要。

## 垃圾收集器概述

### 垃圾收集器分类
- **按线程数分类**：单线程收集器、多线程收集器
- **按工作模式分类**：串行收集器、并行收集器、并发收集器
- **按适用场景分类**：客户端收集器、服务端收集器

### 垃圾收集器发展历程
- **Serial收集器**：最早的垃圾收集器
- **Parallel收集器**：多线程并行收集
- **CMS收集器**：并发收集器
- **G1收集器**：区域化收集器
- **ZGC收集器**：低延迟收集器

## Serial收集器

### 特点
- **单线程**：只有一个线程进行垃圾回收
- **串行执行**：垃圾回收时停止所有应用线程
- **适合客户端**：适合客户端应用

### 算法
- **新生代**：使用复制算法
- **老年代**：使用标记整理算法

### 适用场景
- **客户端应用**：桌面应用、小程序
- **小内存应用**：内存小于100MB的应用
- **单核CPU**：单核CPU环境

### 配置参数
```bash
# 启用Serial收集器
-XX:+UseSerialGC
```

### 优缺点
**优点**：
- 实现简单
- 内存开销小
- 适合小内存应用

**缺点**：
- 停顿时间长
- 不适合大内存应用
- 不适合多核CPU

## ParNew收集器

### 特点
- **多线程**：多个线程并行进行垃圾回收
- **新生代专用**：专门用于新生代垃圾回收
- **配合CMS**：通常与CMS收集器配合使用

### 算法
- **新生代**：使用复制算法
- **多线程并行**：多个线程并行执行

### 适用场景
- **服务端应用**：服务端Java应用
- **多核CPU**：多核CPU环境
- **配合CMS**：与CMS收集器配合使用

### 配置参数
```bash
# 启用ParNew收集器
-XX:+UseParNewGC

# 设置并行线程数
-XX:ParallelGCThreads=4
```

### 优缺点
**优点**：
- 多线程并行
- 适合多核CPU
- 新生代回收效率高

**缺点**：
- 只能用于新生代
- 需要配合其他收集器
- 线程切换开销

## Parallel Scavenge收集器

### 特点
- **多线程并行**：多个线程并行进行垃圾回收
- **注重吞吐量**：优先考虑吞吐量
- **自适应调优**：可以自动调优参数

### 算法
- **新生代**：使用复制算法
- **老年代**：使用标记整理算法

### 适用场景
- **服务端应用**：注重吞吐量的服务端应用
- **批处理应用**：批处理任务
- **科学计算**：科学计算应用

### 配置参数
```bash
# 启用Parallel Scavenge收集器
-XX:+UseParallelGC

# 设置最大停顿时间
-XX:MaxGCPauseMillis=200

# 设置吞吐量目标
-XX:GCTimeRatio=19

# 启用自适应调优
-XX:+UseAdaptiveSizePolicy
```

### 优缺点
**优点**：
- 吞吐量高
- 自适应调优
- 适合批处理应用

**缺点**：
- 停顿时间不可控
- 不适合交互式应用
- 调优复杂

## Serial Old收集器

### 特点
- **单线程**：只有一个线程进行垃圾回收
- **老年代专用**：专门用于老年代垃圾回收
- **配合Serial**：通常与Serial收集器配合使用

### 算法
- **老年代**：使用标记整理算法
- **单线程执行**：单线程执行垃圾回收

### 适用场景
- **客户端应用**：桌面应用
- **小内存应用**：内存较小的应用
- **单核CPU**：单核CPU环境

### 配置参数
```bash
# 启用Serial Old收集器
-XX:+UseSerialGC
```

### 优缺点
**优点**：
- 实现简单
- 内存开销小
- 适合小内存应用

**缺点**：
- 停顿时间长
- 不适合大内存应用
- 不适合多核CPU

## Parallel Old收集器

### 特点
- **多线程并行**：多个线程并行进行垃圾回收
- **老年代专用**：专门用于老年代垃圾回收
- **配合Parallel Scavenge**：通常与Parallel Scavenge收集器配合使用

### 算法
- **老年代**：使用标记整理算法
- **多线程并行**：多个线程并行执行

### 适用场景
- **服务端应用**：服务端Java应用
- **多核CPU**：多核CPU环境
- **注重吞吐量**：注重吞吐量的应用

### 配置参数
```bash
# 启用Parallel Old收集器
-XX:+UseParallelOldGC
```

### 优缺点
**优点**：
- 多线程并行
- 适合多核CPU
- 吞吐量高

**缺点**：
- 停顿时间不可控
- 不适合低延迟应用
- 调优复杂

## CMS收集器

### 特点
- **并发收集**：垃圾回收时应用线程可以继续运行
- **低停顿时间**：追求低停顿时间
- **标记清除算法**：使用标记清除算法

### 算法过程
1. **初始标记**：标记GC Roots直接引用的对象
2. **并发标记**：并发标记所有可达对象
3. **重新标记**：修正并发标记期间的变化
4. **并发清除**：并发清除垃圾对象

### 适用场景
- **低延迟应用**：对延迟敏感的应用
- **交互式应用**：交互式应用
- **Web应用**：Web应用

### 配置参数
```bash
# 启用CMS收集器
-XX:+UseConcMarkSweepGC

# 设置并发线程数
-XX:ConcGCThreads=4

# 设置CMS收集器触发阈值
-XX:CMSInitiatingOccupancyFraction=70

# 启用CMS收集器
-XX:+UseCMSInitiatingOccupancyOnly
```

### 优缺点
**优点**：
- 低停顿时间
- 并发收集
- 适合交互式应用

**缺点**：
- 内存碎片
- CPU资源消耗
- 不适合大内存应用

## G1收集器

### 特点
- **区域化收集**：将内存分为多个区域
- **可预测停顿**：可以预测停顿时间
- **适合大内存**：适合大内存应用

### 算法
- **整体**：使用标记整理算法
- **局部**：使用复制算法
- **区域化**：每个区域独立管理

### 适用场景
- **大内存应用**：内存大于4GB的应用
- **低延迟应用**：对延迟敏感的应用
- **可预测停顿**：需要可预测停顿时间的应用

### 配置参数
```bash
# 启用G1收集器
-XX:+UseG1GC

# 设置最大停顿时间
-XX:MaxGCPauseMillis=200

# 设置区域大小
-XX:G1HeapRegionSize=16m

# 设置并发线程数
-XX:ConcGCThreads=4
```

### 优缺点
**优点**：
- 可预测停顿
- 适合大内存
- 内存利用率高

**缺点**：
- 实现复杂
- 调优困难
- 不适合小内存应用

## 垃圾收集器选择

### 选择原则
1. **应用特点**：根据应用特点选择
2. **硬件环境**：根据硬件环境选择
3. **性能要求**：根据性能要求选择
4. **调优能力**：根据调优能力选择

### 选择建议
- **客户端应用**：Serial收集器
- **服务端应用**：Parallel收集器
- **低延迟应用**：CMS或G1收集器
- **大内存应用**：G1收集器

### 配置示例
```bash
# 客户端应用配置
-XX:+UseSerialGC

# 服务端应用配置
-XX:+UseParallelGC

# 低延迟应用配置
-XX:+UseConcMarkSweepGC

# 大内存应用配置
-XX:+UseG1GC
```

## 性能调优

### 调优目标
- **吞吐量**：提高应用吞吐量
- **延迟**：降低GC停顿时间
- **内存利用率**：提高内存利用率

### 调优方法
1. **参数调优**：调整GC参数
2. **算法选择**：选择合适的GC算法
3. **硬件优化**：优化硬件配置
4. **应用优化**：优化应用代码

### 监控指标
- **GC频率**：监控GC触发频率
- **GC耗时**：监控GC执行时间
- **内存使用**：监控内存使用情况
- **停顿时间**：监控GC停顿时间

## 总结

JVM垃圾收集器是垃圾回收算法的具体实现，理解各种垃圾收集器的特点和应用场景对于选择合适的GC策略至关重要。在实际开发中，应该根据应用的特点和需求来选择合适的垃圾收集器，并进行相应的性能调优。

—— 完 ——
